/* channel.cpp
 * Channel and associated classes
 */

#include "config.h"

#include "daemon.h"
#include "user.h"
#include "channel.h"
#include "numerics.h"
#include "language.h"
#include "utils.h"
#include "modes.h"


// Channel modes -- IMPORTANT: Update the mode strings as you update the table!
char const *Channel::modeStr		= "abdeEhiIklmnoOpqrRstv";
char const *Channel::modeParamStr 	= "bdehIkloOv";
char const *Channel::prefixStr		= "(ohv)@%+";
struct Channel::modeTableStruct const Channel::modeTable[] = {
     { 'a',	MODE_ANONYMOUS,		false,	false,	true,
	toggleChanmodeANONYMOUS 
     },
     { 'b',	0,			true,	true,	true,
	toggleChanmodeBAN 
     },
     { 'd',	0,			true,	true,	true,
	toggleChanmodeDENY 
     },
     { 'e',	0,			true,	true,	true,
	toggleChanmodeBANEXCEPT 
     },
     { 'E',	MODE_EVENT,		false,	false,	true,
	toggleChanmodeEVENT
     },
     { 'h',	0,			true,	true,	true,
	toggleChanmodeHALFOPER
     },
     { 'i',	MODE_INVITE,		false,	false,	true,
	toggleChanmodeINVITE
     },
     { 'I',	0,			true,	true,	true,
	toggleChanmodeINVITEALLOW
     },
     { 'k',	0,			true,	true,	true,
	toggleChanmodeKEY
     },
     { 'l',	0,			true,	false,	true,
	toggleChanmodeLIMIT
     },
     { 'm',	MODE_MODERATED,		false,	false,	true,
	toggleChanmodeMODERATED
     },
     { 'n',	MODE_NOOUTSIDEMSG,	false,	false,	true,
	toggleChanmodeNOOUTSIDEMSG
     },
     { 'o',	0,			true,	true,	true,
	toggleChanmodeCHANOPER
     },
     { 'O',	0,			true,	true,	false,
	toggleChanmodeCHANCREATOR
     },
     { 'p',	MODE_PRIVATE,		false,	false,	true,
	toggleChanmodePRIVATE
     },
     { 'q',	MODE_QUIET,		false,	false,	false,
	toggleChanmodeQUIET
     },
     { 'r',	MODE_REOP,		false,	false,	false,
	toggleChanmodeREOP
     },
     { 'R',	MODE_REGNICKSONLY,	false,	false,	true,
	toggleChanmodeREGNICKSONLY
     },
     { 's',	MODE_SECRET,		false,	false,	true,
	toggleChanmodeSECRET
     },
     { 't',	MODE_TOPICLOCK,		false,	false,	true,
	toggleChanmodeTOPICLOCK
     },
     { 'v',	0,			true,	true,	true,
	toggleChanmodeVOICE
     },
     { 0 }
};


/* ~Channel - Channel class destructor
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
Channel::~Channel(void)
{
   // Run through the mask lists to kill them off
   ChannelMask *mask;
   
   while (!bans.empty()) {
      mask = *bans.begin();
      bans.erase(bans.begin());
      delete mask;
   }
   
   while (!exceptions.empty()) {
      mask = *exceptions.begin();
      exceptions.erase(exceptions.begin());
      delete mask;
   }

   while (!invites.empty()) {
      mask = *invites.begin();
      invites.erase(invites.begin());
      delete mask;
   }
   
   // Wipe out the members list for safety
   members.clear();
}


/* getMember - Grab a channel member record
 * Original 24/08/01, Simon Butcher <pickle@austnet.org>
 */
ChannelMember *Channel::getMember(User *u)
{
   String nick = u->nickname.IRCtoLower();
   ChannelMember *cm = 0;
   
   // Grab the record if we can
   cm = members[nick];
   
   // Make sure we got it
   if (cm) {
      return cm;
   }
   
   // Else we gotta delete this empty record we just make and return nothing
   members.erase(nick);
   
   return 0;
}


/* processModes - Grab a channel member record
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
void Channel::processModes(Handler *handler, User *user,
			   String &modes, StringTokens *tokens)
{
   // This channel must support modes... check this first
   if (name[0] == '+') {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_NOCHANMODES, 0,
			      name + LNG_ERR_NOCHANMODES);
      }
      return;
   }
   
   /* Notice how we COPY the channel member record. This is so that multiple
    * changes where an access removal might occur, eg. user with the nickname
    * 'nick1' is setting the mode to deop 'nick1' and op 'nick2'. Without this
    * a /mode #channel -o+o nick1 nick2 would result in nick1 being deopped
    * but nick2 not being opped because of nick1 now being deopped. This is
    * incorrect as the calling user's modes need to remain static over the
    * entire mode string
    */
   ChannelMember cm;
   
   // If this is a user request, grab the user record
   if (handler) {
      ChannelMember *cmTemp = getMember(user);
      
      // Check we got this user...
      if (!cmTemp) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_NOTONCHANNEL, 0,
			      name + LNG_ERR_NOTONCHANNEL);
	 return;
      }
      
      // Copy the data into our real channel member record
      cm = *cmTemp;
   }
   
   bool toggle = true;
   int numModes = 0;
   String param = "";
   String toggleOnStr = "";
   String toggleOffStr = "";
   String toggleParamsOn = "";
   String toggleParamsOff = "";
   
   for (String::length_t i = 0;
	((i < modes.length()) && (numModes < MAX_MODES_PER_COMMAND));
	i++) {
      switch (modes[i]) {
       case '+':
	 toggle = true;
	 continue;
       case '-':
	 toggle = false;
	 continue;
       default:
	 bool gotModeChar = false;
	 numModes++;
	 
	 // Run though the channel mode list
	 for (int ii = 0; modeTable[ii].letter != 0; ii++) {
	    if (modeTable[ii].letter == modes[i]) {
	       // Can we modify this mode?
	       if ((handler && modeTable[ii].userToggle) ||
		   !handler) {
		  // If this mode needs a parameter, grab the next token...
		  if ((toggle && modeTable[ii].hasParamOn) ||
		      (!toggle && modeTable[ii].hasParamOff)) {
		     param = tokens->nextToken();
		  } else {
		     // Reset the parameter thing
		     param = "";
		  }
		  
		  // Run the toggler for this mode, checking if it worked
		  if (modeTable[ii].toggler(toggle, handler, this, &cm,
					    &user->nickname, &param)) {
		     // Check which toggle string to add this to
		     if (toggle) {
			toggleOnStr = toggleOnStr + String(modes[i]);
			
			// If this mode had a parameter, add it to the list
			if (param.length()) {
			   toggleParamsOn = toggleParamsOn + " " + param;
			}
		     } else {
			toggleOffStr = toggleOffStr + String(modes[i]);
			
			// If this mode had a parameter, add it to the list
			if (param.length()) {
			   toggleParamsOff = toggleParamsOff + " " + param;
			}
		     }
		  }
	       } else {
		  // Complain to the user that they cannot change this mode
		  if (handler) {
		     handler->sendNumeric(TO_DAEMON->myServer(),
					  ERR_CANNOTCHANGECHANMODE, 0,
					  String::printf(LNG_ERR_CANNOTCHANGECHANMODE,
							 modes[i]));
		  }
	       }
	       
	       gotModeChar = true;
	    }
	 }
	 
	 // Check if we found a valid char. If not, complain about it if we can
	 if (!gotModeChar && handler) {
	    handler->sendNumeric(TO_DAEMON->myServer(),
				 ERR_UNKNOWNMODE, 0,
				 String::printf(LNG_ERR_UNKNOWNMODE,
						modes[i], 
						(char const *)name));
	 }
      }
   }

   // Assemble the mode change string
   String modeString = "";
   
   if (toggleOnStr.length()) {
      modeString = String('+') + toggleOnStr;
   }
   if (toggleOffStr.length()) {
      modeString = modeString + String('-') + toggleOffStr;
   }
   if (toggleParamsOn.length()) {
      modeString = modeString + toggleParamsOn;
   }
   if (toggleParamsOff.length()) {
      modeString = modeString + toggleParamsOff;
   }

   if (modeString.length()) {
      // Broadcast the change to local clients on this channel
      for (Channel::member_map_t::iterator it = members.begin();
	   it != members.end(); it++) {
	 if ((*it).second->user->local) {
	    (*it).second->user->local->handler->sendChannelMode(this, user, 
								modeString);
	 }
      }
      
      // Broadcast this change to the network
   }
}


/* isBan - Check if a user is on the channel ban list
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::onBan(User *u)
{
   for (Channel::mask_list_t::iterator it = bans.begin();
	it != bans.end(); it++) {
      if ((*it)->mask.matches(u->getVWAddress().toLower()) || 
	  (*it)->mask.matches(u->getAddress().toLower())) {
	 return true;
      }
   }
   
   return false;
}


/* isBanExcept - Check if a user is on the channel ban exception list
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::onBanExcept(User *u)
{
   for (Channel::mask_list_t::iterator it = exceptions.begin();
	it != exceptions.end(); it++) {
      if ((*it)->mask.matches(u->getVWAddress().toLower()) ||
	  (*it)->mask.matches(u->getAddress().toLower())) {
	 return true;
      }
   }
   
   return false;
}


/* isInvite - Check if a user is on the channel invite list
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::onInvite(User *u)
{ 
   for (Channel::mask_list_t::iterator it = invites.begin();
	it != invites.end(); it++) {
      if ((*it)->mask.matches(u->getVWAddress().toLower()) ||
	  (*it)->mask.matches(u->getAddress().toLower())) {
	 return true;
      }
   }
   
  return false;
}


/* sendNotice - Send a NOTICE to this channel
 * Original 01/09/01, Simon Butcher <pickle@austnet.org>
 */
void Channel::sendNotice(User *from, String const &message)
{
   for (Channel::member_map_t::iterator it = members.begin();
	it != members.end(); it++) {
      // Check if this is the user who sent the message (we do not echo)
      if ((*it).second->user == from) {
	 continue;
      }
      
      // If this user is local, then this is very easy!
      if ((*it).second->user->local) {
	 // Real users?
	 if (!(modes & MODE_ANONYMOUS)) {
	    (*it).second->user->local->handler->sendNotice(from, this,
							   message);
	    continue;
	 }
	 
	 // Send the message under anonymous mask instead
	 (*it).second->user->local->handler->sendNoticeAnon(this, message);
	 continue;
      } 
      
      // stuff to route this message here.
   }
}


/* sendPrivmsg - Send a PRIVMSG to this channel
 * Original 01/09/01, Simon Butcher <pickle@austnet.org>
 */
void Channel::sendPrivmsg(User *from, String const &message)
{
   for (Channel::member_map_t::iterator it = members.begin();
	it != members.end(); it++) {
      // Check if this is the user who sent the message (we do not echo)
      if ((*it).second->user == from) {
	 continue;
      }
      
      // If this user is local, then this is very easy!
      if ((*it).second->user->local) {
	 // Real users?
	 if (!(modes & MODE_ANONYMOUS)) {
	    (*it).second->user->local->handler->sendPrivmsg(from, this, 
							    message);
	    continue;
	 }
	 
	 // Send the message under anonymous mask instead
	 (*it).second->user->local->handler->sendPrivmsgAnon(this, message);
	 continue;
      }
      
      // stuff to route this message here.
   }
}


/* makeModes - Create a string of channel modes according to what is set
 * Original 24/08/01, Simon Butcher <pickle@austnet.org>
 */
String Channel::makeModes(Channel *channel)
{
   String reply = "+";
   String params = "";
   
   // Run through the list of standard modes and check what needs to be shown
   for (int i = 0; modeTable[i].letter != 0; i++) {
      // Check if this mode flag is set
      if (channel->modes & modeTable[i].flag) {
	 reply = reply + String(modeTable[i].letter);
      }
   }
   
   // Parameter based modes
   if (channel->key.length()) {
      reply = reply + "k";
      params = String(" ") + channel->key;
   }
   if (channel->limit > 0) {
      reply = reply + "l";
      params = params + " " + String(channel->limit);
   }
   
   return reply + params;
}
