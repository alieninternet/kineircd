/* channel.cpp
 * Channel and associated classes
 * 
 * Copyright (c) 2001,2002 AustHex Development Team
 * (See DEV-TEAM file for details)
 *
 * This file is a part of AustHex.
 * 
 * AustHex is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AustHex is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AustHex; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include "austhex/austhexconf.h"

#include "austhex/daemon.h"
#include "austhex/user.h"
#include "austhex/channel.h"
#include "austhex/numerics.h"
#include "austhex/utils.h"
#include "austhex/lang.h"


// Channel modes -- IMPORTANT: Update the mode strings as you update the table!
char const *Channel::modeStr = 
  "abdeEhiIklmnoOpqrRstv";
char const *Channel::modeParamStr = 
  "bdehIkloOv";
char const *Channel::prefixStr = 
  "(-ohv).@%+";
struct Channel::modeTableStruct const Channel::modeTable[] = {
     { 'a',	M_ANONYMOUS,		false,	false,	true,
	Channel::toggleModeANONYMOUS 
     },
     { 'b',	0,			true,	true,	true,
	Channel::toggleModeBAN 
     },
     { 'd',	0,			true,	true,	true,
	Channel::toggleModeDENY 
     },
     { 'e',	0,			true,	true,	true,
	Channel::toggleModeBANEXCEPT 
     },
     { 'E',	M_EVENT,		false,	false,	true,
	Channel::toggleModeEVENT
     },
     { 'h',	0,			true,	true,	true,
	Channel::toggleModeHALFOPER
     },
     { 'i',	M_INVITE,		false,	false,	true,
	Channel::toggleModeINVITE
     },
     { 'I',	0,			true,	true,	true,
	Channel::toggleModeINVITEALLOW
     },
     { 'k',	0,			true,	true,	true,
	Channel::toggleModeKEY
     },
     { 'l',	0,			true,	false,	true,
	Channel::toggleModeLIMIT
     },
     { 'm',	M_MODERATED,		false,	false,	true,
	Channel::toggleModeMODERATED
     },
     { 'n',	M_NOOUTSIDEMSG,		false,	false,	true,
	Channel::toggleModeNOOUTSIDEMSG
     },
     { 'o',	0,			true,	true,	true,
	Channel::toggleModeCHANOPER
     },
     { 'O',	0,			true,	true,	false,
	Channel::toggleModeCHANCREATOR
     },
     { 'p',	M_PRIVATE,		false,	false,	true,
	Channel::toggleModePRIVATE
     },
     { 'q',	M_QUIET,		false,	false,	false,
	Channel::toggleModeQUIET
     },
     { 'r',	M_REOP,			false,	false,	false,
	Channel::toggleModeREOP
     },
     { 'R',	M_REGNICKSONLY,		false,	false,	true,
	Channel::toggleModeREGNICKSONLY
     },
     { 's',	M_SECRET,		false,	false,	true,
	Channel::toggleModeSECRET
     },
     { 't',	M_TOPICLOCK,		false,	false,	true,
	Channel::toggleModeTOPICLOCK
     },
     { 'v',	0,			true,	true,	true,
	Channel::toggleModeVOICE
     },
     { 0 }
};


/* ~Channel - Channel class destructor
 * Original 30/08/01 simonb
 */
Channel::~Channel(void)
{
   // Run through the mask lists to kill them off
   ChannelMask *mask;
   
   while (!bans.empty()) {
      mask = *bans.begin();
      bans.erase(bans.begin());
      delete mask;
   }
   
   while (!exceptions.empty()) {
      mask = *exceptions.begin();
      exceptions.erase(exceptions.begin());
      delete mask;
   }

   while (!invites.empty()) {
      mask = *invites.begin();
      invites.erase(invites.begin());
      delete mask;
   }
   
   // Wipe out the members list for safety
   members.clear();
}


/* getMember - Grab a channel member record
 * Original 24/08/01 simonb
 */
ChannelMember *Channel::getMember(User *u)
{
   String nick = u->nickname.IRCtoLower();
   ChannelMember *cm = 0;
   
   // Grab the record if we can
   cm = members[nick];
   
   // Make sure we got it
   if (cm) {
      return cm;
   }
   
   // Else we gotta delete this empty record we just make and return nothing
   members.erase(nick);
   
   return 0;
}


/* okName - Check if a channel name is ok
 * Original 20/08/01 simonb
 */
bool Channel::okName(String const &channel)
{
   // Check that the nickname is within limits
   if (channel.length() > 
       Daemon::getConfig().getOptionsLimitsChannelsMaxNameLength()) {
      return false;
   }

   // Check the first char of the channel (duh!)
   if (!isChannel(channel)) {
      return false;
   }

   // Run through the nickname and look for nasty characters
   for (String::size_type i = channel.length(); i--;) {
#ifdef STRICT_CHANNEL_NAMES
      /* Check for nasty chars. Notice the second check is for a blank char
       * ("No-Break Space" according to the ISO), and people use it especially
       * as an alternative to ordinary space to get around protocol limitations
       * and to spoof channels, eg. "#Foo " in a channel list can look like 
       * "#Foo" in many, if not all clients.
       */
      if (channel[i] < 33) {
	 return false;
      }
#endif
      
      switch (channel[i]) {
#ifdef STRICT_CHANNEL_NAMES
       case char(0xA0): // Used by a lot of people as an alternative space
#else
       case '\0': // Nasty chars less than char 33
       case '\a':
       case '\r':
       case '\n':
       case ' ':
#endif
       case ',': // Chars used in the protocol
       case ':':
	 return false;
      }
   }

   return true;
}


/* processModes - Grab a channel member record
 * Original 30/08/01 simonb
 */
void Channel::processModes(Handler *handler, User *user,
			   String &modes, StringTokens *tokens)
{
   // This channel must support modes... check this first
   if (name[0] == '+') {
      if (handler) {
	 handler->sendNumeric(Daemon::myServer(),
			      Numerics::ERR_NOCHANMODES, 0,
			      name + " :" +
			      user->lang(LangTags::L_ERR_NOCHANMODES));
      }
      return;
   }
   
   /* Notice how we COPY the channel member record. This is so that multiple
    * changes where an access removal might occur, eg. user with the nickname
    * 'nick1' is setting the mode to deop 'nick1' and op 'nick2'. Without this
    * a /mode #channel -o+o nick1 nick2 would result in nick1 being deopped
    * but nick2 not being opped because of nick1 now being deopped. This is
    * incorrect as the calling user's modes need to remain static over the
    * entire mode string
    */
   ChannelMember cm;
   
   // If this is a user request, grab the user record
   if (handler) {
      ChannelMember *cmTemp = getMember(user);
      
      // Check we got this user...
      if (!cmTemp) {
	 // This language assignment should not presume local info!! :(
	 handler->
	   sendNumeric(Daemon::myServer(),
		       Numerics::ERR_NOTONCHANNEL, 0,
		       name + " :" +
		       user->lang(LangTags::L_ERR_NOTONCHANNEL));
	 return;
      }
      
      // Copy the data into our real channel member record
      cm = *cmTemp;
   }
   
   bool toggle = true;
   int numModes = 0;
   String param, toggleOnStr, toggleOffStr, toggleParamsOn, toggleParamsOff;
   
   for (String::size_type i = 0;
	((i < modes.length()) && (numModes < MAX_MODES_PER_COMMAND));
	i++) {
      switch (modes[i]) {
       case '+':
	 toggle = true;
	 continue;
       case '-':
	 toggle = false;
	 continue;
       default:
	 bool gotModeChar = false;
	 numModes++;
	 
	 // Run though the channel mode list
	 for (int ii = 0; modeTable[ii].letter != 0; ii++) {
	    if (modeTable[ii].letter == modes[i]) {
	       // Can we modify this mode?
	       if ((handler && modeTable[ii].userToggle) ||
		   !handler) {
		  // If this mode needs a parameter, grab the next token...
		  if ((toggle && modeTable[ii].hasParamOn) ||
		      (!toggle && modeTable[ii].hasParamOff)) {
		     param = tokens->nextToken();
		  } else {
		     // Reset the parameter thing
		     param = "";
		  }
		  
		  // Run the toggler for this mode, checking if it worked
		  if (modeTable[ii].toggler(toggle, handler, this, &cm,
					    &user->nickname, &param)) {
		     // Check which toggle string to add this to
		     if (toggle) {
			toggleOnStr = toggleOnStr + String(modes[i]);
			
			// If this mode had a parameter, add it to the list
			if (param.length()) {
			   toggleParamsOn = toggleParamsOn + " " + param;
			}
		     } else {
			toggleOffStr = toggleOffStr + String(modes[i]);
			
			// If this mode had a parameter, add it to the list
			if (param.length()) {
			   toggleParamsOff = toggleParamsOff + " " + param;
			}
		     }
		  }
	       } else {
		  // Complain to the user that they cannot change this mode
		  if (handler) {
		     handler->
		       sendNumeric(Daemon::myServer(),
				   Numerics::ERR_CANNOTCHANGECHANMODE, 0,
				   modes[i] + " :" +
				   user->lang(LangTags::L_ERR_CANNOTCHANGECHANMODE));
		  }
	       }
	       
	       gotModeChar = true;
	    }
	 }
	 
	 // Check if we found a valid char. If not, complain about it if we can
	 if (!gotModeChar && handler) {
	    handler->
	      sendNumeric(Daemon::myServer(),
			  Numerics::ERR_UNKNOWNMODE, 0,
			  modes[i] + " :" +
			  user->lang(LangTags::E_ERR_UNKNOWNMODE));
	 }
      }
   }

   // Assemble the mode change string
   String modeString;
   
   if (toggleOnStr.length()) {
      modeString = String('+') + toggleOnStr;
   }
   if (toggleOffStr.length()) {
      modeString = modeString + String('-') + toggleOffStr;
   }
   if (toggleParamsOn.length()) {
      modeString = modeString + toggleParamsOn;
   }
   if (toggleParamsOff.length()) {
      modeString = modeString + toggleParamsOff;
   }

   if (modeString.length()) {
      // Broadcast the change to local clients on this channel
      for (Channel::member_map_t::iterator it = members.begin();
	   it != members.end(); it++) {
	 if ((*it).second->user->local) {
	    (*it).second->user->local->handler->sendChannelMode(this, user, 
								modeString);
	 }
      }
      
      // Broadcast this change to the network
   }
}


/* isBan - Check if a user is on the channel ban list
 * Original 30/08/01 simonb
 */
bool Channel::onBan(User *u)
{
   for (Channel::mask_list_t::iterator it = bans.begin();
	it != bans.end(); it++) {
      if ((*it)->mask.matches(u->getVWAddress().toLower()) || 
	  (*it)->mask.matches(u->getAddress().toLower())) {
	 return true;
      }
   }
   
   return false;
}


/* isBanExcept - Check if a user is on the channel ban exception list
 * Original 30/08/01 simonb
 */
bool Channel::onBanExcept(User *u)
{
   for (Channel::mask_list_t::iterator it = exceptions.begin();
	it != exceptions.end(); it++) {
      if ((*it)->mask.matches(u->getVWAddress().toLower()) ||
	  (*it)->mask.matches(u->getAddress().toLower())) {
	 return true;
      }
   }
   
   return false;
}


/* isInvite - Check if a user is on the channel invite list
 * Original 30/08/01 simonb
 */
bool Channel::onInvite(User *u)
{ 
   for (Channel::mask_list_t::iterator it = invites.begin();
	it != invites.end(); it++) {
      if ((*it)->mask.matches(u->getVWAddress().toLower()) ||
	  (*it)->mask.matches(u->getAddress().toLower())) {
	 return true;
      }
   }
   
  return false;
}


/* sendNotice - Send a NOTICE to this channel
 * Original 01/09/01 simonb
 */
void Channel::sendNotice(User *from, String const &message)
{
   for (Channel::member_map_t::iterator it = members.begin();
	it != members.end(); it++) {
      // Check if this is the user who sent the message (we do not echo)
      if ((*it).second->user == from) {
	 continue;
      }
      
      // If this user is local, then this is very easy!
      if ((*it).second->user->local) {
	 // Real users?
	 if (!(modes & M_ANONYMOUS)) {
	    (*it).second->user->local->handler->sendNotice(from, this,
							   message);
	    continue;
	 }
	 
	 // Send the message under anonymous mask instead
	 (*it).second->user->local->handler->sendNoticeAnon(this, message);
	 continue;
      } 

      // stuff to route this message here.
   }
}


/* sendPrivmsg - Send a PRIVMSG to this channel
 * Original 01/09/01 simonb
 */
void Channel::sendPrivmsg(User *from, String const &message)
{
   for (Channel::member_map_t::iterator it = members.begin();
	it != members.end(); it++) {
      // Check if this is the user who sent the message (we do not echo)
      if ((*it).second->user == from) {
	 continue;
      }
      
      // If this user is local, then this is very easy!
      if ((*it).second->user->local) {
	 // Real users?
	 if (!(modes & M_ANONYMOUS)) {
	    (*it).second->user->local->handler->sendPrivmsg(from, this, 
							    message);
	    continue;
	 }
	 
	 // Send the message under anonymous mask instead
	 (*it).second->user->local->handler->sendPrivmsgAnon(this, message);
	 continue;
      }
      
      // stuff to route this message here.
   }
}


/* sendKnock - Send a KNOCK request to this channel
 * Original 24/10/01 simonb
 */
void Channel::sendKnock(User *from, String const &reason)
{
   for (Channel::member_map_t::iterator it = members.begin();
	it != members.end(); it++) {
      // Check if this is the user who sent the message (we do not echo)
      if ((*it).second->user == from) {
	 continue;
      }
      
      // If this user is local, then this is very easy!
      if ((*it).second->user->local) {
	 (*it).second->user->local->handler->sendKnock(from, this, reason);
	 continue;
      }
      
      // stuff to route this message here.
   }
}


/* makeModes - Create a string of channel modes according to what is set
 * Original 24/08/01 simonb
 */
String Channel::makeModes(Channel *channel)
{
   String reply = "+", params;
   
   // Run through the list of standard modes and check what needs to be shown
   for (int i = 0; modeTable[i].letter != 0; i++) {
      // Check if this mode flag is set
      if (channel->modes & modeTable[i].flag) {
	 reply = reply + String(modeTable[i].letter);
      }
   }
   
   // Parameter based modes
   if (channel->key.length()) {
      reply = reply + "k";
      params = String(" ") + channel->key;
   }
   if (channel->limit > 0) {
      reply = reply + "l";
      params = params + " " + String::convert(channel->limit);
   }
   
   return reply + params;
}


/* Channel::toggleModeANONYMOUS
 * Original 30/08/01 simonb
 */
bool Channel::toggleModeANONYMOUS(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   /* If this is a ! channel, this can only be set/removed by the CREATOR.
    * In our case, so far, we cannot have a safe-channel creator so we just
    * fail any requests to do this on a safe channel
    */
   if (channel->name[0] == '!') {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(),
		       Numerics::ERR_UNIQOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_UNIQOPRIVSNEEDED));
      }
      return false;
   }
   
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::M_OPPED) &&
       !(member->modes & ChannelMember::M_HALFOPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::M_ANONYMOUS)) {
      channel->modes |= Channel::M_ANONYMOUS;
      return true;
   } else if (!setting && (channel->modes & Channel::M_ANONYMOUS)) {
      channel->modes &= ~Channel::M_ANONYMOUS;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeBAN
 * Original 28/08/01 simonb
 */
bool Channel::toggleModeBAN(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check if the user is requesting the ban list
   if (!param->length()) {
      if (handler) {
	 for (Channel::mask_list_t::iterator it = channel->bans.begin();
	      it != channel->bans.end(); it++) {
	    handler->sendNumeric(Daemon::myServer(),
				 Numerics::RPL_BANLIST, 0,
				 channel->name + ' ' +
				 (*it)->mask.getMask() + ' ' +
				 (*it)->whoset + ' ' +
				 String::convert((*it)->whenset));
	 }

	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::RPL_ENDOFBANLIST, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_RPL_ENDOFBANLIST));
      }
      
      // Return false since no mode was actually changed
      return false;
   }

   // Check that this user is a channel operator
   if (member && !(member->modes & ChannelMember::M_OPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   *param = param->toLower();
   
   // Are we setting or removing a mask?
   if (setting) {
      // Look for this mask in the list to check it is not already set
      for (Channel::mask_list_t::iterator it = channel->bans.begin();
	   it != channel->bans.end(); it++) {
	 if ((*it)->mask.getMask().toLower() == *param) {
	    return false;
	 }
      }

      // Create a new mask and add it to the list
      channel->
	bans.push_front(new ChannelMask(Utils::fixToIdentityMask(*param),
					*setter,
					Daemon::getTime()));

      return true;
   } else {
      ChannelMask *mask;
      
      // Find this mask in the list
      for (Channel::mask_list_t::iterator it = channel->bans.begin();
	   it != channel->bans.end(); it++) {
	 // Check for a match
	 if ((*it)->mask.getMask().toLower() == *param) {
	    mask = *it;
	    channel->bans.erase(it);
	    delete mask;
	    return true;
	 }
      }
   }
   
   return false;
}


/* Channel::toggleModeBANEXCEPT
 * Original 28/08/01 simonb
 */
bool Channel::toggleModeBANEXCEPT(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check if the user is requesting the ban exception list
   if (!param->length()) {
      if (handler) {
	 for (Channel::mask_list_t::iterator it = 
	      channel->exceptions.begin();
	      it != channel->exceptions.end(); it++) {
	    handler->sendNumeric(Daemon::myServer(),
				 Numerics::RPL_EXCEPTLIST, 0,
				 channel->name + ' ' +
				 (*it)->mask.getMask() + ' ' +
				 (*it)->whoset + ' ' +
				 String::convert((*it)->whenset));
	 }

	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::RPL_ENDOFEXCEPTLIST, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_RPL_ENDOFEXCEPTLIST));
      }
      
      // Return false since no mode was actually changed
      return false;
   }

   // Check that this user is a channel operator
   if (member && !(member->modes & ChannelMember::M_OPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   *param = param->toLower();
   
   // Are we setting or removing a mask?
   if (setting) {
      // Look for this mask in the list to check it is not already set
      for (Channel::mask_list_t::iterator it = channel->exceptions.begin();
	   it != channel->exceptions.end(); it++) {
	 if ((*it)->mask.getMask().toLower() == *param) {
	    return false;
	 }
      }

      // Create a new mask and add it to the list
      channel->
	exceptions.push_front(new ChannelMask(Utils::fixToIdentityMask(*param),
					      *setter,
					      Daemon::getTime()));

      return true;
   } else {
      ChannelMask *mask;
      
      // Find this mask in the list
      for (Channel::mask_list_t::iterator it = channel->exceptions.begin();
	   it != channel->exceptions.end(); it++) {
	 // Check for a match
	 if ((*it)->mask.getMask().toLower() == *param) {
	    mask = *it;
	    channel->exceptions.erase(it);
	    delete mask;
	    return true;
	 }
      }
   }
   
   return false;
}


/* Channel::toggleModeCHANCREATOR
 * Original  simonb
 */
bool Channel::toggleModeCHANCREATOR(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   return false;
}


/* Channel::toggleModeCHANOPER
 * Original 31/08/01 simonb
 */
bool Channel::toggleModeCHANOPER(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // If no parameter was given, ignore this
   if (!param->length()) {
      return false;
   }
   
   // Check that this user is a channel operator
   if (member && !(member->modes & ChannelMember::M_OPPED)) {
      if (handler) {
	 // If they are a half oper, give them a better explanation
	 if (member->modes & ChannelMember::M_HALFOPPED) {
	    handler->
	      sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
			  channel->name + " :" +
			  member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
	 } else {
	    handler->
	      sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
			  channel->name + " :" + 
			  member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED_HALFOPERVSOPER));
	 }
      }
      return false;
   }
   
   /* Look up this nickname. We should check that it is valid but most of
    * the time it will be valid so checking would be a waste of time, 
    * perhaps...
    */
   User *u = Daemon::getUser(*param);
   
   // Check..
   if (!u) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_NOSUCHNICK, 0,
		       *param + " :" +
		       member->getUser()->lang(LangTags::L_ERR_NOSUCHNICK_NICK));
      }
      return false;
   }
   
   // Grab the channel member record for this user
   ChannelMember *cm = channel->getMember(u);
   
   // Check..
   if (!cm) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(),
		       Numerics::ERR_USERNOTINCHANNEL, 0,
		       u->nickname + ' ' +
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_USERNOTINCHANNEL));
      }
      return false;
   }

   // Check if this user is immune from deopping
   if (u->modes & User::M_NONKICKABLE) {
      handler->
	sendNumeric(Daemon::myServer(), Numerics::ERR_ISCHANSERVICE, 0,
		    u->nickname + ' ' +
		    channel->name + ' ' +
		    member->getUser()->lang(LangTags::L_ERR_ISCHANSERVICE));
      return false;
   }
      
   
   // OK!! Are we setting or removing this status?
   if (setting) {
      // Check that this channel member is not already opped
      if (cm->modes & ChannelMember::M_OPPED) {
	 return false;
      }
      
      // Set the mode, finally
      cm->modes |= ChannelMember::M_OPPED;
   } else {
      // Check that this channel member is already deopped
      if (!(cm->modes & ChannelMember::M_OPPED)) {
	 return false;
      }
      
      // Remove the flag
      cm->modes &= ~ChannelMember::M_OPPED;
   }
   
   // Make the parameter string a little more accurate, for neatness!
   *param = cm->user->nickname;
   
   // We made it!
   return true;
}


/* Channel::toggleModeDENY
 * Original  simonb
 */
bool Channel::toggleModeDENY(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   return true;
}


/* Channel::toggleModeEVENT
 * Original 30/08/01 simonb
 */
bool Channel::toggleModeEVENT(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::M_OPPED) &&
       !(member->modes & ChannelMember::M_HALFOPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::M_EVENT)) {
      channel->modes |= Channel::M_EVENT;
      return true;
   } else if (!setting && (channel->modes & Channel::M_EVENT)) {
      channel->modes &= ~Channel::M_EVENT;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeHALFOPER
 * Original 19/09/01 simonb
 */
bool Channel::toggleModeHALFOPER(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // If no parameter was given, ignore this
   if (!param->length()) {
      return false;
   }
   
   // If the member is themselves, we can skip a few steps..
   if (member->user->nickname.IRCtoLower() == param->IRCtoLower()) {
      // The user can dehalfop themselves, but cannot halfop themselves.
      if (!(member->modes & ChannelMember::M_HALFOPPED) &&
	  !(member->modes & ChannelMember::M_OPPED)) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
	 return false;
      }
   } else {
      // Check that this user is a channel operator
      if (member && 
	  !(member->modes & ChannelMember::M_OPPED) &&
	  !(member->modes & ChannelMember::M_HALFOPPED)) {
	 if (handler) {
	    handler->
	      sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
			  channel->name + " :" +
			  member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
	 }
	 return false;
      }
   }
   
   /* Look up this nickname. We should check that it is valid but most of
    * the time it will be valid so checking would be a waste of time, 
    * perhaps...
    */
   User *u = Daemon::getUser(*param);
   
   // Check..
   if (!u) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_NOSUCHNICK, 0,
		       *param + " :" +
		       member->getUser()->lang(LangTags::L_ERR_NOSUCHNICK_NICK));
      }
      return false;
   }
   
   // Grab the channel member record for this user
   ChannelMember *cm = channel->getMember(u);
   
   // Check..
   if (!cm) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(),
		       Numerics::ERR_USERNOTINCHANNEL, 0,
		       u->nickname + ' ' +
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_USERNOTINCHANNEL));
      }
      return false;
   }
   
   // OK!! Are we setting or removing this status?
   if (setting) {
      // Check that this channel member is not already opped
      if (cm->modes & ChannelMember::M_HALFOPPED) {
	 return false;
      }
      
      // Set the mode, finally
      cm->modes |= ChannelMember::M_HALFOPPED;
   } else {
      // Check that this channel member is already deopped
      if (!(cm->modes & ChannelMember::M_HALFOPPED)) {
	 return false;
      }
      
      // Remove the flag
      cm->modes &= ~ChannelMember::M_HALFOPPED;
   }
   
   // Make the parameter string a little more accurate, for neatness!
   *param = cm->user->nickname;
   
   // We made it!
   return true;
}


/* Channel::toggleModeINVITE
 * Original 30/08/01 simonb
 */
bool Channel::toggleModeINVITE(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::M_OPPED) &&
       !(member->modes & ChannelMember::M_HALFOPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::M_INVITE)) {
      channel->modes |= Channel::M_INVITE;
      return true;
   } else if (!setting && (channel->modes & Channel::M_INVITE)) {
      channel->modes &= ~Channel::M_INVITE;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeINVITEALLOW
 * Original 28/08/01 simonb
 */
bool Channel::toggleModeINVITEALLOW(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check if the user is requesting the ban exception list
   if (!param->length()) {
      if (handler) {
	 for (Channel::mask_list_t::iterator it = channel->invites.begin();
	      it != channel->invites.end(); it++) {
	    handler->	      
	      sendNumeric(Daemon::myServer(),
			  Numerics::RPL_INVITELIST, 0,
			  channel->name + ' ' +
			  (*it)->mask.getMask() + ' ' +
			  (*it)->whoset + ' ' +
			  String::convert((*it)->whenset));
	 }

	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::RPL_ENDOFINVITELIST, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_RPL_ENDOFINVITELIST));
      }

      // Return false since no mode was actually changed
      return false;
   }

   // Check that this user is a channel operator
   if (member && !(member->modes & ChannelMember::M_OPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   *param = param->toLower();
   
   // Are we setting or removing a mask?
   if (setting) {
      // Look for this mask in the list to check it is not already set
      for (Channel::mask_list_t::iterator it = channel->invites.begin();
	   it != channel->invites.end(); it++) {
	 if ((*it)->mask.getMask().toLower() == *param) {
	    return false;
	 }
      }

      // Create a new mask and add it to the list
      channel->
	invites.push_front(new ChannelMask(Utils::fixToIdentityMask(*param),
					   *setter,
					   Daemon::getTime()));

      return true;
   } else {
      ChannelMask *mask;
      
      // Find this mask in the list
      for (Channel::mask_list_t::iterator it = channel->invites.begin();
	   it != channel->invites.end(); it++) {
	 // Check for a match
	 if ((*it)->mask.getMask().toLower() == *param) {
	    mask = *it;
	    channel->invites.erase(it);
	    delete mask;
	    return true;
	 }
      }
   }
   
   return false;
}


/* Channel::toggleModeKEY
 * Original 30/08/01 simonb
 */
bool Channel::toggleModeKEY(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::M_OPPED) &&
       !(member->modes & ChannelMember::M_HALFOPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   if (setting) {
      // Make sure we are not resetting the key, got to unset it first
      if (channel->key.length()) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_KEYSET, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_KEYSET));
	 return false;
      }
      
      // Make sure we were given something to set as the key!
      if (param->length()) {
	 channel->key = *param;
	 return true;
      }
      
      return false;
   } else if (!setting && (channel->key.length())) {
      // Check that the key matches the one already set
      if (channel->key != *param) {
	 return false;
      }
      
      channel->key = "";
      *param = "";
      return true;
   }

   return false;
}


/* Channel::toggleModeLIMIT
 * Original 30/08/01 simonb
 * Note: We reset the parameter here to make the reply 'safe'
 */
bool Channel::toggleModeLIMIT(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::M_OPPED) &&
       !(member->modes & ChannelMember::M_HALFOPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   if (setting) {
      long limit = param->toLong();
      
      // Check that worked ok
      if (limit <= 0) {
	 return false;
      }

      channel->limit = param->toLong();
      *param = String::convert(channel->limit);
      return true;
   } else if (!setting && (channel->limit > 0)) {
      channel->limit = 0;
      *param = "";
      return true;
   }
   
   return false;
}


/* Channel::toggleModeMODERATED
 * Original 30/08/01 simonb
 */
bool Channel::toggleModeMODERATED(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::M_OPPED) &&
       !(member->modes & ChannelMember::M_HALFOPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::M_MODERATED)) {
      channel->modes |= Channel::M_MODERATED;
      return true;
   } else if (!setting && (channel->modes & Channel::M_MODERATED)) {
      channel->modes &= ~Channel::M_MODERATED;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeNOOUTSIDEMSG
 * Original 30/08/01 simonb
 */
bool Channel::toggleModeNOOUTSIDEMSG(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::M_OPPED) &&
       !(member->modes & ChannelMember::M_HALFOPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::M_NOOUTSIDEMSG)) {
      channel->modes |= Channel::M_NOOUTSIDEMSG;
      return true;
   } else if (!setting && (channel->modes & Channel::M_NOOUTSIDEMSG)) {
      channel->modes &= ~Channel::M_NOOUTSIDEMSG;
      return true;
   }
   
   return false;
}


/* Channel::toggleModePRIVATE
 * Original 30/08/01 simonb
 */
bool Channel::toggleModePRIVATE(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::M_OPPED) &&
       !(member->modes & ChannelMember::M_HALFOPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::M_PRIVATE)) {
      channel->modes |= Channel::M_PRIVATE;
      return true;
   } else if (!setting && (channel->modes & Channel::M_PRIVATE)) {
      channel->modes &= ~Channel::M_PRIVATE;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeREGNICKSONLY
 * Original 30/08/01 simonb
 */
bool Channel::toggleModeREGNICKSONLY(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::M_OPPED) &&
       !(member->modes & ChannelMember::M_HALFOPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::M_REGNICKSONLY)) {
      channel->modes |= Channel::M_REGNICKSONLY;
      return true;
   } else if (!setting && (channel->modes & Channel::M_REGNICKSONLY)) {
      channel->modes &= ~Channel::M_REGNICKSONLY;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeSECRET
 * Original 30/08/01 simonb
 */
bool Channel::toggleModeSECRET(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::M_OPPED) &&
       !(member->modes & ChannelMember::M_HALFOPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::M_SECRET)) {
      channel->modes |= Channel::M_SECRET;
      return true;
   } else if (!setting && (channel->modes & Channel::M_SECRET)) {
      channel->modes &= ~Channel::M_SECRET;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeTOPICLOCK
 * Original 30/08/01 simonb
 */
bool Channel::toggleModeTOPICLOCK(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::M_OPPED) &&
       !(member->modes & ChannelMember::M_HALFOPPED)) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::M_TOPICLOCK)) {
      channel->modes |= Channel::M_TOPICLOCK;
      return true;
   } else if (!setting && (channel->modes & Channel::M_TOPICLOCK)) {
      channel->modes &= ~Channel::M_TOPICLOCK;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeQUIET
 * Original 22/09/01 simonb
 */
bool Channel::toggleModeQUIET(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   if (setting && !(channel->modes & Channel::M_QUIET)) {
      channel->modes |= Channel::M_QUIET;
      return true;
   } else if (!setting && (channel->modes & Channel::M_QUIET)) {
      channel->modes &= ~Channel::M_QUIET;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeREOP
 * Original 22/09/01 simonb
 */
bool Channel::toggleModeREOP(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   if (setting && !(channel->modes & Channel::M_REOP)) {
      channel->modes |= Channel::M_REOP;
      return true;
   } else if (!setting && (channel->modes & Channel::M_REOP)) {
      channel->modes &= ~Channel::M_REOP;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeVOICE
 * Original 31/08/01 simonb
 */
bool Channel::toggleModeVOICE(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // If no parameter was given, ignore this
   if (!param->length()) {
      return false;
   }
   
   // If the member is themselves, we can skip a few steps..
   if (member->user->nickname.IRCtoLower() == param->IRCtoLower()) {
      // The user can devoice themselves, but cannot voice themselves.
      if (setting && 
	  !(member->modes & ChannelMember::M_OPPED) &&
	  !(member->modes & ChannelMember::M_HALFOPPED)) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
		       channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
	 return false;
      }
   } else {
      // Check that this user is a channel operator
      if (member && 
	  !(member->modes & ChannelMember::M_OPPED) &&
	  !(member->modes & ChannelMember::M_HALFOPPED)) {
	 if (handler) {
	    handler->
	      sendNumeric(Daemon::myServer(), Numerics::ERR_CHANOPRIVSNEEDED, 0,
			  channel->name + " :" +
			  member->getUser()->lang(LangTags::L_ERR_CHANOPRIVSNEEDED));
	 }
	 return false;
      }
   }
   
   /* Look up this nickname. We should check that it is valid but most of
    * the time it will be valid so checking would be a waste of time, 
    * perhaps...
    */
   User *u = Daemon::getUser(*param);
   
   // Check..
   if (!u) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(), Numerics::ERR_NOSUCHNICK, 0,
		       *param + " :" +
		       member->getUser()->lang(LangTags::L_ERR_NOSUCHNICK_NICK));
      }
      return false;
   }
   
   // Grab the channel member record for this user
   ChannelMember *cm = channel->getMember(u);
   
   // Check..
   if (!cm) {
      if (handler) {
	 handler->
	   sendNumeric(Daemon::myServer(),
		       Numerics::ERR_USERNOTINCHANNEL, 0,
		       u->nickname + ' ' + channel->name + " :" +
		       member->getUser()->lang(LangTags::L_ERR_USERNOTINCHANNEL));
      }
      return false;
   }
   
   // OK!! Are we setting or removing this status?
   if (setting) {
      // Check that this channel member is not already voiced!
      if (cm->modes & ChannelMember::M_VOICED) {
	 return false;
      }
      
      // Set the mode, finally
      cm->modes |= ChannelMember::M_VOICED;
   } else {
      // Check that this channel member is already devoiced
      if (!(cm->modes & ChannelMember::M_VOICED)) {
	 return false;
      }
      
      // Remove the flag
      cm->modes &= ~ChannelMember::M_VOICED;
   }
   
   // Make the parameter string a little more accurate, for neatness!
   *param = cm->user->nickname;
   
   // We made it!
   return true;
}


