/* channel.cpp
 * Channel and associated classes
 */

#include "config.h"

#include "daemon.h"
#include "user.h"
#include "channel.h"
#include "numerics.h"
#include "language.h"
#include "utils.h"


// Channel modes -- IMPORTANT: Update the mode strings as you update the table!
char const *Channel::modeStr		= "abdeEhiIklmnoOpqrRstv";
char const *Channel::modeParamStr 	= "bdehIkloOv";
char const *Channel::prefixStr		= "(ohv)@%+";
struct Channel::modeTableStruct const Channel::modeTable[] = {
     { 'a',	MODE_ANONYMOUS,		false,	false,	true,
	Channel::toggleModeANONYMOUS 
     },
     { 'b',	0,			true,	true,	true,
	Channel::toggleModeBAN 
     },
     { 'd',	0,			true,	true,	true,
	Channel::toggleModeDENY 
     },
     { 'e',	0,			true,	true,	true,
	Channel::toggleModeBANEXCEPT 
     },
     { 'E',	MODE_EVENT,		false,	false,	true,
	Channel::toggleModeEVENT
     },
     { 'h',	0,			true,	true,	true,
	Channel::toggleModeHALFOPER
     },
     { 'i',	MODE_INVITE,		false,	false,	true,
	Channel::toggleModeINVITE
     },
     { 'I',	0,			true,	true,	true,
	Channel::toggleModeINVITEALLOW
     },
     { 'k',	0,			true,	true,	true,
	Channel::toggleModeKEY
     },
     { 'l',	0,			true,	false,	true,
	Channel::toggleModeLIMIT
     },
     { 'm',	MODE_MODERATED,		false,	false,	true,
	Channel::toggleModeMODERATED
     },
     { 'n',	MODE_NOOUTSIDEMSG,	false,	false,	true,
	Channel::toggleModeNOOUTSIDEMSG
     },
     { 'o',	0,			true,	true,	true,
	Channel::toggleModeCHANOPER
     },
     { 'O',	0,			true,	true,	false,
	Channel::toggleModeCHANCREATOR
     },
     { 'p',	MODE_PRIVATE,		false,	false,	true,
	Channel::toggleModePRIVATE
     },
     { 'q',	MODE_QUIET,		false,	false,	false,
	Channel::toggleModeQUIET
     },
     { 'r',	MODE_REOP,		false,	false,	false,
	Channel::toggleModeREOP
     },
     { 'R',	MODE_REGNICKSONLY,	false,	false,	true,
	Channel::toggleModeREGNICKSONLY
     },
     { 's',	MODE_SECRET,		false,	false,	true,
	Channel::toggleModeSECRET
     },
     { 't',	MODE_TOPICLOCK,		false,	false,	true,
	Channel::toggleModeTOPICLOCK
     },
     { 'v',	0,			true,	true,	true,
	Channel::toggleModeVOICE
     },
     { 0 }
};


/* ~Channel - Channel class destructor
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
Channel::~Channel(void)
{
   // Run through the mask lists to kill them off
   ChannelMask *mask;
   
   while (!bans.empty()) {
      mask = *bans.begin();
      bans.erase(bans.begin());
      delete mask;
   }
   
   while (!exceptions.empty()) {
      mask = *exceptions.begin();
      exceptions.erase(exceptions.begin());
      delete mask;
   }

   while (!invites.empty()) {
      mask = *invites.begin();
      invites.erase(invites.begin());
      delete mask;
   }
   
   // Wipe out the members list for safety
   members.clear();
}


/* getMember - Grab a channel member record
 * Original 24/08/01, Simon Butcher <pickle@austnet.org>
 */
ChannelMember *Channel::getMember(User *u)
{
   String nick = u->nickname.IRCtoLower();
   ChannelMember *cm = 0;
   
   // Grab the record if we can
   cm = members[nick];
   
   // Make sure we got it
   if (cm) {
      return cm;
   }
   
   // Else we gotta delete this empty record we just make and return nothing
   members.erase(nick);
   
   return 0;
}


/* processModes - Grab a channel member record
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
void Channel::processModes(Handler *handler, User *user,
			   String &modes, StringTokens *tokens)
{
   // This channel must support modes... check this first
   if (name[0] == '+') {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_NOCHANMODES, 0,
			      name + LNG_ERR_NOCHANMODES);
      }
      return;
   }
   
   /* Notice how we COPY the channel member record. This is so that multiple
    * changes where an access removal might occur, eg. user with the nickname
    * 'nick1' is setting the mode to deop 'nick1' and op 'nick2'. Without this
    * a /mode #channel -o+o nick1 nick2 would result in nick1 being deopped
    * but nick2 not being opped because of nick1 now being deopped. This is
    * incorrect as the calling user's modes need to remain static over the
    * entire mode string
    */
   ChannelMember cm;
   
   // If this is a user request, grab the user record
   if (handler) {
      ChannelMember *cmTemp = getMember(user);
      
      // Check we got this user...
      if (!cmTemp) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_NOTONCHANNEL, 0,
			      name + LNG_ERR_NOTONCHANNEL);
	 return;
      }
      
      // Copy the data into our real channel member record
      cm = *cmTemp;
   }
   
   bool toggle = true;
   int numModes = 0;
   String param = "";
   String toggleOnStr = "";
   String toggleOffStr = "";
   String toggleParamsOn = "";
   String toggleParamsOff = "";
   
   for (String::length_t i = 0;
	((i < modes.length()) && (numModes < MAX_MODES_PER_COMMAND));
	i++) {
      switch (modes[i]) {
       case '+':
	 toggle = true;
	 continue;
       case '-':
	 toggle = false;
	 continue;
       default:
	 bool gotModeChar = false;
	 numModes++;
	 
	 // Run though the channel mode list
	 for (int ii = 0; modeTable[ii].letter != 0; ii++) {
	    if (modeTable[ii].letter == modes[i]) {
	       // Can we modify this mode?
	       if ((handler && modeTable[ii].userToggle) ||
		   !handler) {
		  // If this mode needs a parameter, grab the next token...
		  if ((toggle && modeTable[ii].hasParamOn) ||
		      (!toggle && modeTable[ii].hasParamOff)) {
		     param = tokens->nextToken();
		  } else {
		     // Reset the parameter thing
		     param = "";
		  }
		  
		  // Run the toggler for this mode, checking if it worked
		  if (modeTable[ii].toggler(toggle, handler, this, &cm,
					    &user->nickname, &param)) {
		     // Check which toggle string to add this to
		     if (toggle) {
			toggleOnStr = toggleOnStr + String(modes[i]);
			
			// If this mode had a parameter, add it to the list
			if (param.length()) {
			   toggleParamsOn = toggleParamsOn + " " + param;
			}
		     } else {
			toggleOffStr = toggleOffStr + String(modes[i]);
			
			// If this mode had a parameter, add it to the list
			if (param.length()) {
			   toggleParamsOff = toggleParamsOff + " " + param;
			}
		     }
		  }
	       } else {
		  // Complain to the user that they cannot change this mode
		  if (handler) {
		     handler->sendNumeric(TO_DAEMON->myServer(),
					  ERR_CANNOTCHANGECHANMODE, 0,
					  String::printf(LNG_ERR_CANNOTCHANGECHANMODE,
							 modes[i]));
		  }
	       }
	       
	       gotModeChar = true;
	    }
	 }
	 
	 // Check if we found a valid char. If not, complain about it if we can
	 if (!gotModeChar && handler) {
	    handler->sendNumeric(TO_DAEMON->myServer(),
				 ERR_UNKNOWNMODE, 0,
				 String::printf(LNG_ERR_UNKNOWNMODE,
						modes[i], 
						(char const *)name));
	 }
      }
   }

   // Assemble the mode change string
   String modeString = "";
   
   if (toggleOnStr.length()) {
      modeString = String('+') + toggleOnStr;
   }
   if (toggleOffStr.length()) {
      modeString = modeString + String('-') + toggleOffStr;
   }
   if (toggleParamsOn.length()) {
      modeString = modeString + toggleParamsOn;
   }
   if (toggleParamsOff.length()) {
      modeString = modeString + toggleParamsOff;
   }

   if (modeString.length()) {
      // Broadcast the change to local clients on this channel
      for (Channel::member_map_t::iterator it = members.begin();
	   it != members.end(); it++) {
	 if ((*it).second->user->local) {
	    (*it).second->user->local->handler->sendChannelMode(this, user, 
								modeString);
	 }
      }
      
      // Broadcast this change to the network
   }
}


/* isBan - Check if a user is on the channel ban list
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::onBan(User *u)
{
   for (Channel::mask_list_t::iterator it = bans.begin();
	it != bans.end(); it++) {
      if ((*it)->mask.matches(u->getVWAddress().toLower()) || 
	  (*it)->mask.matches(u->getAddress().toLower())) {
	 return true;
      }
   }
   
   return false;
}


/* isBanExcept - Check if a user is on the channel ban exception list
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::onBanExcept(User *u)
{
   for (Channel::mask_list_t::iterator it = exceptions.begin();
	it != exceptions.end(); it++) {
      if ((*it)->mask.matches(u->getVWAddress().toLower()) ||
	  (*it)->mask.matches(u->getAddress().toLower())) {
	 return true;
      }
   }
   
   return false;
}


/* isInvite - Check if a user is on the channel invite list
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::onInvite(User *u)
{ 
   for (Channel::mask_list_t::iterator it = invites.begin();
	it != invites.end(); it++) {
      if ((*it)->mask.matches(u->getVWAddress().toLower()) ||
	  (*it)->mask.matches(u->getAddress().toLower())) {
	 return true;
      }
   }
   
  return false;
}


/* sendNotice - Send a NOTICE to this channel
 * Original 01/09/01, Simon Butcher <pickle@austnet.org>
 */
void Channel::sendNotice(User *from, String const &message)
{
   for (Channel::member_map_t::iterator it = members.begin();
	it != members.end(); it++) {
      // Check if this is the user who sent the message (we do not echo)
      if ((*it).second->user == from) {
	 continue;
      }
      
      // If this user is local, then this is very easy!
      if ((*it).second->user->local) {
	 // Real users?
	 if (!(modes & MODE_ANONYMOUS)) {
	    (*it).second->user->local->handler->sendNotice(from, this,
							   message);
	    continue;
	 }
	 
	 // Send the message under anonymous mask instead
	 (*it).second->user->local->handler->sendNoticeAnon(this, message);
	 continue;
      } 

      // stuff to route this message here.
   }
}


/* sendPrivmsg - Send a PRIVMSG to this channel
 * Original 01/09/01, Simon Butcher <pickle@austnet.org>
 */
void Channel::sendPrivmsg(User *from, String const &message)
{
   for (Channel::member_map_t::iterator it = members.begin();
	it != members.end(); it++) {
      // Check if this is the user who sent the message (we do not echo)
      if ((*it).second->user == from) {
	 continue;
      }
      
      // If this user is local, then this is very easy!
      if ((*it).second->user->local) {
	 // Real users?
	 if (!(modes & MODE_ANONYMOUS)) {
	    (*it).second->user->local->handler->sendPrivmsg(from, this, 
							    message);
	    continue;
	 }
	 
	 // Send the message under anonymous mask instead
	 (*it).second->user->local->handler->sendPrivmsgAnon(this, message);
	 continue;
      }
      
      // stuff to route this message here.
   }
}


/* makeModes - Create a string of channel modes according to what is set
 * Original 24/08/01, Simon Butcher <pickle@austnet.org>
 */
String Channel::makeModes(Channel *channel)
{
   String reply = "+";
   String params = "";
   
   // Run through the list of standard modes and check what needs to be shown
   for (int i = 0; modeTable[i].letter != 0; i++) {
      // Check if this mode flag is set
      if (channel->modes & modeTable[i].flag) {
	 reply = reply + String(modeTable[i].letter);
      }
   }
   
   // Parameter based modes
   if (channel->key.length()) {
      reply = reply + "k";
      params = String(" ") + channel->key;
   }
   if (channel->limit > 0) {
      reply = reply + "l";
      params = params + " " + String(channel->limit);
   }
   
   return reply + params;
}


/* Channel::toggleModeANONYMOUS
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeANONYMOUS(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   /* If this is a ! channel, this can only be set/removed by the CREATOR.
    * In our case, so far, we cannot have a safe-channel creator so we just
    * fail any requests to do this on a safe channel
    */
   if (channel->name[0] == '!') {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_UNIQOPRIVSNEEDED, 0,
			      LNG_ERR_UNIQOPRIVSNEEDED);
      }
      return false;
   }
   
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::MODE_OPPED) &&
       !(member->modes & ChannelMember::MODE_HALFOPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::MODE_ANONYMOUS)) {
      channel->modes |= Channel::MODE_ANONYMOUS;
      return true;
   } else if (!setting && (channel->modes & Channel::MODE_ANONYMOUS)) {
      channel->modes &= ~Channel::MODE_ANONYMOUS;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeBAN
 * Original 28/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeBAN(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check if the user is requesting the ban list
   if (!param->length()) {
      if (handler) {
	 for (Channel::mask_list_t::iterator it = channel->bans.begin();
	      it != channel->bans.end(); it++) {
	    handler->sendNumeric(TO_DAEMON->myServer(),
				 RPL_BANLIST, 0,
				 String::printf("%s %s %s %lu",
						(char const *)channel->name,
						(char const *)(*it)->mask.getMask(),
						(char const *)(*it)->whoset,
						(*it)->whenset));
	 }

	 handler->sendNumeric(TO_DAEMON->myServer(),
			      RPL_ENDOFBANLIST, 0,
			      channel->name + LNG_RPL_ENDOFBANLIST);
      }
      
      // Return false since no mode was actually changed
      return false;
   }

   // Check that this user is a channel operator
   if (member && !(member->modes & ChannelMember::MODE_OPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   *param = param->toLower();
   
   // Are we setting or removing a mask?
   if (setting) {
      // Look for this mask in the list to check it is not already set
      for (Channel::mask_list_t::iterator it = channel->bans.begin();
	   it != channel->bans.end(); it++) {
	 if ((*it)->mask.getMask().toLower() == *param) {
	    return false;
	 }
      }

      // Create a new mask and add it to the list
      channel->bans.push_front(new ChannelMask(fixToIdentityMask(*param),
					       *setter,
					       channel->daemon->getTime()));

      return true;
   } else {
      ChannelMask *mask;
      
      // Find this mask in the list
      for (Channel::mask_list_t::iterator it = channel->bans.begin();
	   it != channel->bans.end(); it++) {
	 // Check for a match
	 if ((*it)->mask.getMask().toLower() == *param) {
	    mask = *it;
	    channel->bans.erase(it);
	    delete mask;
	    return true;
	 }
      }
   }
   
   return false;
}


/* Channel::toggleModeBANEXCEPT
 * Original 28/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeBANEXCEPT(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check if the user is requesting the ban exception list
   if (!param->length()) {
      if (handler) {
	 for (Channel::mask_list_t::iterator it = 
	      channel->exceptions.begin();
	      it != channel->exceptions.end(); it++) {
	    handler->sendNumeric(TO_DAEMON->myServer(),
				 RPL_EXCEPTLIST, 0,
				 String::printf("%s %s %s %lu",
						(char const *)channel->name,
						(char const *)(*it)->mask.getMask(),
						(char const *)(*it)->whoset,
						(*it)->whenset));
	 }

	 handler->sendNumeric(TO_DAEMON->myServer(),
			      RPL_ENDOFEXCEPTLIST, 0,
			      channel->name + LNG_RPL_ENDOFEXCEPTLIST);
      }
      
      // Return false since no mode was actually changed
      return false;
   }

   // Check that this user is a channel operator
   if (member && !(member->modes & ChannelMember::MODE_OPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   *param = param->toLower();
   
   // Are we setting or removing a mask?
   if (setting) {
      // Look for this mask in the list to check it is not already set
      for (Channel::mask_list_t::iterator it = channel->exceptions.begin();
	   it != channel->exceptions.end(); it++) {
	 if ((*it)->mask.getMask().toLower() == *param) {
	    return false;
	 }
      }

      // Create a new mask and add it to the list
      channel->exceptions.push_front(new ChannelMask(fixToIdentityMask(*param),
						     *setter,
						     channel->daemon->getTime()));

      return true;
   } else {
      ChannelMask *mask;
      
      // Find this mask in the list
      for (Channel::mask_list_t::iterator it = channel->exceptions.begin();
	   it != channel->exceptions.end(); it++) {
	 // Check for a match
	 if ((*it)->mask.getMask().toLower() == *param) {
	    mask = *it;
	    channel->exceptions.erase(it);
	    delete mask;
	    return true;
	 }
      }
   }
   
   return false;
}


/* Channel::toggleModeCHANCREATOR
 * Original , Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeCHANCREATOR(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   return false;
}


/* Channel::toggleModeCHANOPER
 * Original 31/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeCHANOPER(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // If no parameter was given, ignore this
   if (!param->length()) {
      return false;
   }
   
   // Check that this user is a channel operator
   if (member && !(member->modes & ChannelMember::MODE_OPPED)) {
      if (handler) {
	 // If they are a half oper, give them a better explanation
	 if (member->modes & ChannelMember::MODE_HALFOPPED) {
	    handler->sendNumeric(TO_DAEMON->myServer(),
				 ERR_CHANOPRIVSNEEDED, 0,
				 channel->name + LNG_ERR_CHANOPRIVSNEEDED);
	 } else {
	    handler->sendNumeric(TO_DAEMON->myServer(),
				 ERR_CHANOPRIVSNEEDED, 0,
				 channel->name + 
				 LNG_ERR_CHANOPRIVSNEEDED_HALFOPERVSOPER);
	 }
      }
      return false;
   }
   
   /* Look up this nickname. We should check that it is valid but most of
    * the time it will be valid so checking would be a waste of time, 
    * perhaps...
    */
   User *u = channel->daemon->getUser(*param);
   
   // Check..
   if (!u) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_NOSUCHNICK, 0,
			      *param + LNG_ERR_NOSUCHNICK_NICK);
      }
      return false;
   }
   
   // Grab the channel member record for this user
   ChannelMember *cm = channel->getMember(u);
   
   // Check..
   if (!cm) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_USERNOTINCHANNEL, 0,
			      String::printf(LNG_ERR_USERNOTINCHANNEL,
					     (char const *)u->nickname,
					     (char const *)channel->name));
      }
      return false;
   }

   // Check if this user is immune from deopping
   if (u->modes & User::MODE_NONKICKABLE) {
      handler->sendNumeric(TO_DAEMON->myServer(),
			   ERR_ISCHANSERVICE, 0,
			   String::printf(LNG_ERR_ISCHANSERVICE,
					  (char const *)u->nickname,
					  (char const *)channel->name));
      return false;
   }
      
   
   // OK!! Are we setting or removing this status?
   if (setting) {
      // Check that this channel member is not already opped
      if (cm->modes & ChannelMember::MODE_OPPED) {
	 return false;
      }
      
      // Set the mode, finally
      cm->modes |= ChannelMember::MODE_OPPED;
   } else {
      // Check that this channel member is already deopped
      if (!(cm->modes & ChannelMember::MODE_OPPED)) {
	 return false;
      }
      
      // Remove the flag
      cm->modes &= ~ChannelMember::MODE_OPPED;
   }
   
   // Make the parameter string a little more accurate, for neatness!
   *param = cm->user->nickname;
   
   // We made it!
   return true;
}


/* Channel::toggleModeDENY
 * Original , Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeDENY(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   return true;
}


/* Channel::toggleModeEVENT
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeEVENT(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::MODE_OPPED) &&
       !(member->modes & ChannelMember::MODE_HALFOPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::MODE_EVENT)) {
      channel->modes |= Channel::MODE_EVENT;
      return true;
   } else if (!setting && (channel->modes & Channel::MODE_EVENT)) {
      channel->modes &= ~Channel::MODE_EVENT;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeHALFOPER
 * Original 19/09/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeHALFOPER(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // If no parameter was given, ignore this
   if (!param->length()) {
      return false;
   }
   
   // If the member is themselves, we can skip a few steps..
   if (member->user->nickname.IRCtoLower() == param->IRCtoLower()) {
      // The user can dehalfop themselves, but cannot halfop themselves.
      if (!(member->modes & ChannelMember::MODE_HALFOPPED) &&
	  !(member->modes & ChannelMember::MODE_OPPED)) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
	 return false;
      }
   } else {
      // Check that this user is a channel operator
      if (member && 
	  !(member->modes & ChannelMember::MODE_OPPED) &&
	  !(member->modes & ChannelMember::MODE_HALFOPPED)) {
	 if (handler) {
	    handler->sendNumeric(TO_DAEMON->myServer(),
				 ERR_CHANOPRIVSNEEDED, 0,
				 channel->name + LNG_ERR_CHANOPRIVSNEEDED);
	 }
	 return false;
      }
   }
   
   /* Look up this nickname. We should check that it is valid but most of
    * the time it will be valid so checking would be a waste of time, 
    * perhaps...
    */
   User *u = channel->daemon->getUser(*param);
   
   // Check..
   if (!u) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_NOSUCHNICK, 0,
			      *param + LNG_ERR_NOSUCHNICK_NICK);
      }
      return false;
   }
   
   // Grab the channel member record for this user
   ChannelMember *cm = channel->getMember(u);
   
   // Check..
   if (!cm) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_USERNOTINCHANNEL, 0,
			      String::printf(LNG_ERR_USERNOTINCHANNEL,
					     (char const *)u->nickname,
					     (char const *)channel->name));
      }
      return false;
   }
   
   // OK!! Are we setting or removing this status?
   if (setting) {
      // Check that this channel member is not already opped
      if (cm->modes & ChannelMember::MODE_HALFOPPED) {
	 return false;
      }
      
      // Set the mode, finally
      cm->modes |= ChannelMember::MODE_HALFOPPED;
   } else {
      // Check that this channel member is already deopped
      if (!(cm->modes & ChannelMember::MODE_HALFOPPED)) {
	 return false;
      }
      
      // Remove the flag
      cm->modes &= ~ChannelMember::MODE_HALFOPPED;
   }
   
   // Make the parameter string a little more accurate, for neatness!
   *param = cm->user->nickname;
   
   // We made it!
   return true;
}


/* Channel::toggleModeINVITE
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeINVITE(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::MODE_OPPED) &&
       !(member->modes & ChannelMember::MODE_HALFOPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::MODE_INVITE)) {
      channel->modes |= Channel::MODE_INVITE;
      return true;
   } else if (!setting && (channel->modes & Channel::MODE_INVITE)) {
      channel->modes &= ~Channel::MODE_INVITE;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeINVITEALLOW
 * Original 28/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeINVITEALLOW(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check if the user is requesting the ban exception list
   if (!param->length()) {
      if (handler) {
	 for (Channel::mask_list_t::iterator it = channel->invites.begin();
	      it != channel->invites.end(); it++) {
	    handler->sendNumeric(TO_DAEMON->myServer(),
				 RPL_INVITELIST, 0,
				 String::printf("%s %s %s %lu",
						(char const *)channel->name,
						(char const *)(*it)->mask.getMask(),
						(char const *)(*it)->whoset,
						(*it)->whenset));
	 }

	 handler->sendNumeric(TO_DAEMON->myServer(),
			      RPL_ENDOFINVITELIST, 0,
			      channel->name + LNG_RPL_ENDOFINVITELIST);
      }

      // Return false since no mode was actually changed
      return false;
   }

   // Check that this user is a channel operator
   if (member && !(member->modes & ChannelMember::MODE_OPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   *param = param->toLower();
   
   // Are we setting or removing a mask?
   if (setting) {
      // Look for this mask in the list to check it is not already set
      for (Channel::mask_list_t::iterator it = channel->invites.begin();
	   it != channel->invites.end(); it++) {
	 if ((*it)->mask.getMask().toLower() == *param) {
	    return false;
	 }
      }

      // Create a new mask and add it to the list
      channel->invites.push_front(new ChannelMask(fixToIdentityMask(*param),
						  *setter,
						  channel->daemon->getTime()));

      return true;
   } else {
      ChannelMask *mask;
      
      // Find this mask in the list
      for (Channel::mask_list_t::iterator it = channel->invites.begin();
	   it != channel->invites.end(); it++) {
	 // Check for a match
	 if ((*it)->mask.getMask().toLower() == *param) {
	    mask = *it;
	    channel->invites.erase(it);
	    delete mask;
	    return true;
	 }
      }
   }
   
   return false;
}


/* Channel::toggleModeKEY
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeKEY(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::MODE_OPPED) &&
       !(member->modes & ChannelMember::MODE_HALFOPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   if (setting) {
      // Make sure we are not resetting the key, got to unset it first
      if (channel->key.length()) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_KEYSET, 0,
			      channel->name + LNG_ERR_KEYSET);
	 return false;
      }
      
      // Make sure we were given something to set as the key!
      if (param->length()) {
	 channel->key = *param;
	 return true;
      }
      
      return false;
   } else if (!setting && (channel->key.length())) {
      // Check that the key matches the one already set
      if (channel->key != *param) {
	 return false;
      }
      
      channel->key = "";
      *param = "";
      return true;
   }

   return false;
}


/* Channel::toggleModeLIMIT
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 * Note: We reset the parameter here to make the reply 'safe'
 */
bool Channel::toggleModeLIMIT(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::MODE_OPPED) &&
       !(member->modes & ChannelMember::MODE_HALFOPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   if (setting) {
      long limit = param->toLong();
      
      // Check that worked ok
      if (limit <= 0) {
	 return false;
      }

      channel->limit = param->toLong();
      *param = String(channel->limit);
      return true;
   } else if (!setting && (channel->limit > 0)) {
      channel->limit = 0;
      *param = "";
      return true;
   }
   
   return false;
}


/* Channel::toggleModeMODERATED
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeMODERATED(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::MODE_OPPED) &&
       !(member->modes & ChannelMember::MODE_HALFOPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::MODE_MODERATED)) {
      channel->modes |= Channel::MODE_MODERATED;
      return true;
   } else if (!setting && (channel->modes & Channel::MODE_MODERATED)) {
      channel->modes &= ~Channel::MODE_MODERATED;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeNOOUTSIDEMSG
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeNOOUTSIDEMSG(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::MODE_OPPED) &&
       !(member->modes & ChannelMember::MODE_HALFOPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::MODE_NOOUTSIDEMSG)) {
      channel->modes |= Channel::MODE_NOOUTSIDEMSG;
      return true;
   } else if (!setting && (channel->modes & Channel::MODE_NOOUTSIDEMSG)) {
      channel->modes &= ~Channel::MODE_NOOUTSIDEMSG;
      return true;
   }
   
   return false;
}


/* Channel::toggleModePRIVATE
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModePRIVATE(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::MODE_OPPED) &&
       !(member->modes & ChannelMember::MODE_HALFOPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::MODE_PRIVATE)) {
      channel->modes |= Channel::MODE_PRIVATE;
      return true;
   } else if (!setting && (channel->modes & Channel::MODE_PRIVATE)) {
      channel->modes &= ~Channel::MODE_PRIVATE;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeREGNICKSONLY
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeREGNICKSONLY(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::MODE_OPPED) &&
       !(member->modes & ChannelMember::MODE_HALFOPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::MODE_REGNICKSONLY)) {
      channel->modes |= Channel::MODE_REGNICKSONLY;
      return true;
   } else if (!setting && (channel->modes & Channel::MODE_REGNICKSONLY)) {
      channel->modes &= ~Channel::MODE_REGNICKSONLY;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeSECRET
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeSECRET(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::MODE_OPPED) &&
       !(member->modes & ChannelMember::MODE_HALFOPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::MODE_SECRET)) {
      channel->modes |= Channel::MODE_SECRET;
      return true;
   } else if (!setting && (channel->modes & Channel::MODE_SECRET)) {
      channel->modes &= ~Channel::MODE_SECRET;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeTOPICLOCK
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeTOPICLOCK(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // Check that this user is a channel operator
   if (member && 
       !(member->modes & ChannelMember::MODE_OPPED) &&
       !(member->modes & ChannelMember::MODE_HALFOPPED)) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
      }
      return false;
   }
   
   if (setting && !(channel->modes & Channel::MODE_TOPICLOCK)) {
      channel->modes |= Channel::MODE_TOPICLOCK;
      return true;
   } else if (!setting && (channel->modes & Channel::MODE_TOPICLOCK)) {
      channel->modes &= ~Channel::MODE_TOPICLOCK;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeQUIET
 * Original 22/09/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeQUIET(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   if (setting && !(channel->modes & Channel::MODE_QUIET)) {
      channel->modes |= Channel::MODE_QUIET;
      return true;
   } else if (!setting && (channel->modes & Channel::MODE_QUIET)) {
      channel->modes &= ~Channel::MODE_QUIET;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeREOP
 * Original 22/09/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeREOP(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   if (setting && !(channel->modes & Channel::MODE_REOP)) {
      channel->modes |= Channel::MODE_REOP;
      return true;
   } else if (!setting && (channel->modes & Channel::MODE_REOP)) {
      channel->modes &= ~Channel::MODE_REOP;
      return true;
   }
   
   return false;
}


/* Channel::toggleModeVOICE
 * Original 31/08/01, Simon Butcher <pickle@austnet.org>
 */
bool Channel::toggleModeVOICE(bool setting, Handler *handler, Channel *channel, ChannelMember *member, String *setter, String *param)
{
   // If no parameter was given, ignore this
   if (!param->length()) {
      return false;
   }
   
   // If the member is themselves, we can skip a few steps..
   if (member->user->nickname.IRCtoLower() == param->IRCtoLower()) {
      // The user can devoice themselves, but cannot voice themselves.
      if (setting && 
	  !(member->modes & ChannelMember::MODE_OPPED) &&
	  !(member->modes & ChannelMember::MODE_HALFOPPED)) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_CHANOPRIVSNEEDED, 0,
			      channel->name + LNG_ERR_CHANOPRIVSNEEDED);
	 return false;
      }
   } else {
      // Check that this user is a channel operator
      if (member && 
	  !(member->modes & ChannelMember::MODE_OPPED) &&
	  !(member->modes & ChannelMember::MODE_HALFOPPED)) {
	 if (handler) {
	    handler->sendNumeric(TO_DAEMON->myServer(),
				 ERR_CHANOPRIVSNEEDED, 0,
				 channel->name + LNG_ERR_CHANOPRIVSNEEDED);
	 }
	 return false;
      }
   }
   
   /* Look up this nickname. We should check that it is valid but most of
    * the time it will be valid so checking would be a waste of time, 
    * perhaps...
    */
   User *u = channel->daemon->getUser(*param);
   
   // Check..
   if (!u) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_NOSUCHNICK, 0,
			      *param + LNG_ERR_NOSUCHNICK_NICK);
      }
      return false;
   }
   
   // Grab the channel member record for this user
   ChannelMember *cm = channel->getMember(u);
   
   // Check..
   if (!cm) {
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      ERR_USERNOTINCHANNEL, 0,
			      String::printf(LNG_ERR_USERNOTINCHANNEL,
					     (char const *)u->nickname,
					     (char const *)channel->name));
      }
      return false;
   }
   
   // OK!! Are we setting or removing this status?
   if (setting) {
      // Check that this channel member is not already voiced!
      if (cm->modes & ChannelMember::MODE_VOICED) {
	 return false;
      }
      
      // Set the mode, finally
      cm->modes |= ChannelMember::MODE_VOICED;
   } else {
      // Check that this channel member is already devoiced
      if (!(cm->modes & ChannelMember::MODE_VOICED)) {
	 return false;
      }
      
      // Remove the flag
      cm->modes &= ~ChannelMember::MODE_VOICED;
   }
   
   // Make the parameter string a little more accurate, for neatness!
   *param = cm->user->nickname;
   
   // We made it!
   return true;
}


