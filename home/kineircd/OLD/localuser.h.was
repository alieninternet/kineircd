/* localuser.h
 * LocalUser class
 */

#ifndef __LOCALUSER_H_
# define __LOCALUSER_H_

# ifdef STL_HAS_HASH
#  include <hash_set>
# else
#  include <set.h>
# endif

class LocalUser;

# include "user.h"
# include "channel.h"
# include "handler.h"
# include "str.h"


// An 'invitation' (for channel invites)
class LocalUserInvitation {
 private:
   String const inviter;			// Sender of the invitation
   int const timeout;				// Seconds this is valid or -1

 public:
   LocalUserInvitation(String const &i, long t)
     : inviter(i),
       timeout(t)
     {};
   
   // Variable access
   String const &getInviter(void) const
     {
	return inviter;
     };
   
   long const getTimeout(void) const
     {
	return timeout;
     };
};


// Locally connected user class
class LocalUser {
 public:
# ifdef STL_HAS_HASH
   typedef hash_set <String> watch_set_t;
# else
   typedef set <String> watch_set_t;
# endif
   
   // The invitations list should never get long enough to warrant hashing
   typedef map <String, LocalUserInvitation *> invitation_map_t;
   
   typedef map <String, time_t> floodlock_reply_map_t;
   
 public:
   User *user;					// Link into main user class
   Handler *handler;				// Link into user handler

   snotice_bitmask_t serverNotices;		// Server notices to receive
   
   watch_set_t watches;				// Watching these nicknames
   invitation_map_t invitations;		// Invitations to channels
   
# ifdef FLOODLOCK_AWAY_REPLY
   floodlock_reply_map_t awayReplyFloodlocks;	// Timeout on 'x is away' msgs
# endif

   bool onReplyFloodlockMap(floodlock_reply_map_t &,
			    User *);		// Check an away-reply lock

 public:
   // Constructor
   LocalUser(User *u, Handler *h)
     : user(u),
       handler(h),
       serverNotices(0)
     {
	watches.clear();
	invitations.clear();
# ifdef FLOODLOCK_AWAY_REPLY
	awayReplyFloodlocks.clear();
# endif
     };
   
   // Destructor
   ~LocalUser(void)
     {
	watches.clear();
	invitations.clear();
# ifdef FLOODLOCK_AWAY_REPLY
	awayReplyFloodlocks.clear();
# endif
     };

   // Add to the watch list
   void addWatch(const String &target)
     {
	watches.insert(target);
     };
   
   // Remote from the watch list
   void delWatch(const String &target)
     {
	watches.erase(target);
     };
   
   // Wipe the watches list
   void wipeWatches(void)
     {
	watches.clear();
     };
   
   // Check for a watched nick
   bool watching(String const &target) const
     {
	return ((watches.find(target) != watches.end()) ? true : false);
     };

   
   void addInvitation(Channel *, User *, 
		      time_t);			// Invite us to a channel
   
   // Delete a channel invitation
   void delInvitation(Channel *channel)
     {
	invitations.erase(channel->getName());
     };

   bool invitedTo(Channel *);			// Check an invitation

# ifdef FLOODLOCK_AWAY_REPLY
   // Check if a user is on our away-reply floodlock map
   bool onAwayReplyFloodlock(User *u)
     {
	return onReplyFloodlockMap(awayReplyFloodlocks, u);
     }
# endif
};

#endif

