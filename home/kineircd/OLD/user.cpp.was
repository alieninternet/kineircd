/* user.cpp
 * User and associated classes
 */

#include "config.h"

#include <ctype.h>

#include "daemon.h"
#include "user.h"
#include "localuser.h"
#include "channel.h"
#include "numerics.h"
#include "language.h"
#include "utils.h"


// User modes -- IMPORTANT: Update the mode strings as you update the table!
char const *User::modeStr = 
  "dghkiInoOrRsSvw\241";
char const *User::modeParamStr = 
  "s";
struct User::modeTableStruct const User::modeTable[] = {
     { 'd',	MODE_DEAF,		false,	false,	true,
	User::toggleModeDEAF
     },
     { 'g',	MODE_IGNORING,		false,	false,	false,
	User::toggleModeIGNORING
     },
     { 'h',	MODE_HELPER,		false,	false,	true,
	User::toggleModeHELPER
     },
     { 'k',	MODE_NONKICKABLE,	false,	false,	false,
	User::toggleModeNONKICKABLE
     },
     { 'i',	MODE_INVISIBLE,		false,	false,	true,
	User::toggleModeINVISIBLE
     },
     { 'I',	MODE_IDENTIFIED,	false,	false,	false,
	User::toggleModeIDENTIFIED
     },
     { 'n',	MODE_GOT_IDENTD,	false,	false,	false,
	User::toggleModeGOT_IDENTD
     },
     { 'o',	MODE_LOCALOPER,		false,	false,	true,
	User::toggleModeOPER
     },
     { 'O',	MODE_GLOBALOPER,	false,	false,	true,
	User::toggleModeOPER
     },
     { 'r',	MODE_RESTRICTED,	false,	false,	false,
	User::toggleModeRESTRICTED
     },
     { 'R',	MODE_REGNICKSMSG,	false,	false,	true,
	User::toggleModeREGNICKSMSG
     },
     { 's',	0,			true,	false,	true,
	User::toggleModeSERVNOTICES
     },
     { 'S',	MODE_SECURE,		false,	false,	false,
	User::toggleModeSECURE
     },
     { 'v',	MODE_VWORLD,		false,	false,	true,
	User::toggleModeVWORLD
     },
     { 'w',	MODE_WALLOPS,		false,	false,	true,
	User::toggleModeWALLOPS
     },
     { '\241',	MODE_ROUTINGSTAFF,	false,	false,	false,
	User::toggleModeROUTINGSTAFF
     },
     { 0 }
};


/* getChannel - Look through our local channel list for a channel
 * Original 15/08/01, Simon Butcher <pickle@austnet.org>
 * Note: Minature version of what appears for the main channel list, why
 *       we do this is for speed purposes mainly
 */
Channel *User::getChannel(String &channel)
{
   // Look for this channel
   String chan = channel.IRCtoLower();
   Channel *c = channels[chan];
   
   // Make sure we got this user
   if (c) {
      return c;
   };
   
   // Else we gotta delete this empty record we just made and return nothing
   channels.erase(chan);

   return 0;
}


/* markAway - Toggle the user's away 
 * Original 11/09/01, Simon Butcher <pickle@austnet.org
 */
void User::markAway(String const &message)
{
   // Set the away message
   awayMessage = message;
   
   // Broadcast the change
   
}


/* isSilencing - Check if the given user matches a mask on our silence list
 * Original 24/09/01, Simon Butcher <pickle@austnet.org>
 */
bool User::isSilencing(User *target)
{
   // Run through the list to find the mask
   for (silence_list_t::iterator it = silences.begin();
	it != silences.end(); it++) {
      // Check for a match on either the real or virtual world addresses
      if (it->matches(target->getAddress()) ||
	  it->matches(target->getVWAddress())) {
	 return true;
      }
   }
   
   // Must not be on the list..
   return false;
}


/* okName - Check if a nickname contains ok characters and is short enough
 * Original 12/08/01, Simon Butcher <pickle@austnet.org>
 */
bool User::okName(String const &nick)
{
   // Check that the nickname is within limits
   if (nick.length() > MAXLEN_NICKNAME) {
      return false;
   }

   // Check the first char, it cannot be a number
   if (isdigit(nick[0])) {
      return false;
   }
   
   // Run through the nickname and look for nasty characters
   for (String::length_t i = nick.length(); i--;) {
      char c = nick[i];

      if (!(isalnum(c) || 
	    (((c > 0x5A) && (c < 0x61)) || // check 'special' (see RFC2812)
	     ((c > 0x7A) && (c < 0x7E))) ||
	    (c == '-'))) {
	 return false;
      }
   }

   return true;
}


/* makeModes - [Various forms] Create a string of user modes
 * Original 24/08/01, Simon Butcher <pickle@austnet.org>
 */
String User::makeModes(modes_t modes)
{
   String reply = "+";
   
   // Run through the list of modes and check what needs to be shown
   for (int i = 0; modeTable[i].letter != 0; i++) {
      // Check if this mode flag is set
      if (modes & modeTable[i].flag) {
	 reply = reply + String(modeTable[i].letter);
      }
   }

   return reply;
}

String User::makeModes(User *user)
{
   String reply = "+";
   String params = "";
   
   // Run through the list of modes and check what needs to be shown
   for (int i = 0; modeTable[i].letter != 0; i++) {
      // Check if this mode flag is set
      if (user->modes & modeTable[i].flag) {
	 reply = reply + String(modeTable[i].letter);
      }
   }
   
   // Parameter based modes
   if (user->local && user->local->serverNotices) {
      reply = reply + "s";
      params = String(" ") + "?";
   }
   
   return reply + params;
}


/* User::toggleModeDEAF
 * Original 25/08/01, Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeDEAF(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   if (setting && !(user->modes & User::MODE_DEAF)) {
      user->modes |= User::MODE_DEAF;
      return true;
   } else if (!setting && (user->modes & User::MODE_DEAF)) {
      user->modes &= ~User::MODE_DEAF;
      return true;
   }
   
   return false;
}


/* User::toggleModeGOT_IDENTD
 * Original 22/09/01, Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeGOT_IDENTD(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   if (setting && !(user->modes & User::MODE_GOT_IDENTD)) {
      user->modes |= User::MODE_GOT_IDENTD;
      return true;
   } else if (!setting && (user->modes & User::MODE_GOT_IDENTD)) {
      user->modes &= ~User::MODE_GOT_IDENTD;
      return true;
   }
   
   return false;
}


/* User::toggleModeHELPER
 * Original 22/09/01, Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeHELPER(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   // Check if we are turning this on
   if (setting) {
      if (handler) {
	 /* Tell the user they're an idiot :) */
	 if (!(user->modes & User::MODE_HELPER)) {
	    handler->sendNumeric(TO_DAEMON->myServer(),
				 ERR_NOPRIVILEGES, 0,
				 LNG_ERR_NOPRIVILEGES_PLUS_HELPER);
	 }
	 return false;
      } else {
	 // Turn it on
	 user->modes |= User::MODE_HELPER;
	 
	 // Modify the helper counter
	 daemon->numHelpers++;
	 
	 return true;
      }
   }
   
   // If this user is not a helper, this does not have an effect at all
   if (!(user->modes & User::MODE_HELPER)) {
      return false;
   }
   
   // Turn off the flag and return true
   user->modes &= ~User::MODE_HELPER;

   // Modify the helper counter
   daemon->numHelpers--;
	 
   return true;
}


/* User::toggleModeIDENTIFIED
 * Original 22/09/01, Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeIDENTIFIED(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   if (setting && !(user->modes & User::MODE_IDENTIFIED)) {
      user->modes |= User::MODE_IDENTIFIED;
      return true;
   } else if (!setting && (user->modes & User::MODE_IDENTIFIED)) {
      user->modes &= ~User::MODE_IDENTIFIED;
      return true;
   }
   
   return false;
}


/* User::toggleModeIGNORING
 * Original 22/09/01, Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeIGNORING(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   if (setting && !(user->modes & User::MODE_IGNORING)) {
      user->modes |= User::MODE_IGNORING;
      return true;
   } else if (!setting && (user->modes & User::MODE_IGNORING)) {
      user->modes &= ~User::MODE_IGNORING;
      return true;
   }
   
   return false;
}


/* User::toggleModeINVISIBLE
 * Original 25/08/01, Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeINVISIBLE(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   if (setting && !(user->modes & User::MODE_INVISIBLE)) {
      user->modes |= User::MODE_INVISIBLE;
      return true;
   } else if (!setting && (user->modes & User::MODE_INVISIBLE)) {
      user->modes &= ~User::MODE_INVISIBLE;
      return true;
   }
   
   return false;
}


/* User::toggleModeNONKICKABLE
 * Original 22/09/01, Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeNONKICKABLE(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   if (setting && !(user->modes & User::MODE_NONKICKABLE)) {
      user->modes |= User::MODE_NONKICKABLE;
      return true;
   } else if (!setting && (user->modes & User::MODE_NONKICKABLE)) {
      user->modes &= ~User::MODE_NONKICKABLE;
      return true;
   }
   
   return false;
}


/* User::toggleModeOPER
 * Original 25/08/01, Simon Butcher <pickle@austnet.org>
 * Note: This can only be toggled off, not on.
 */
bool User::toggleModeOPER(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   // Check if this user is trying to turn this mode on
   if (setting) {
      if (handler) {
	 if (!(user->modes & User::MODE_GLOBALOPER) ||
	     !(user->modes & User::MODE_LOCALOPER)) {
	    /* Tell the user they're an idiot :) */
	    handler->sendNumeric(TO_DAEMON->myServer(),
				ERR_NOPRIVILEGES, 0,
				 LNG_ERR_NOPRIVILEGES_PLUS_IRCOPER);
	 }
	 return false;
      } else {
	 // If this is setting someone as a global operator, then turn it on.
	 if (*modeChr == 'O') {
	    user->modes |= User::MODE_GLOBALOPER;
	    return true;
	 }
	 
	 // Ignore it, must be a local oper and a mistake.
	 return false;
      }
   }
   
   // If this user is not an oper, this does not have an effect at all
   if (!(user->modes & User::MODE_GLOBALOPER) &&
       !(user->modes & User::MODE_LOCALOPER)) {
      return false;
   }
   
   // Fix up the character so that the client does not get confused.
   if (user->modes & User::MODE_GLOBALOPER) {
      // While we are here, decrement the global operator counter
      daemon->numOpers--;
      
      *modeChr = 'O';
   } else {
      *modeChr = 'o';
   }
   
   // Turn off the oper flags and return true
   user->modes &= ~User::MODE_GLOBALOPER & ~User::MODE_LOCALOPER;

   return true;
}


/* User::toggleModeREGNICKSMSG
 * Original 30/08/01, Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeREGNICKSMSG(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   if (setting && !(user->modes & User::MODE_REGNICKSMSG)) {
      user->modes |= User::MODE_REGNICKSMSG;

      // If this user is an oper or a helper they really should not have this
      if (handler && User::isHelper(user)) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      RPL_MODECHANGEWARN, 0,
			      LNG_RPL_MODECHANGEWARN_HELPER_PLUS_REGNICKSMSG);
      }
      
      return true;
   } else if (!setting && (user->modes & User::MODE_REGNICKSMSG)) {
      user->modes &= ~User::MODE_REGNICKSMSG;
      return true;
   }
   
   return false;
}


/* User::toggleModeRESTRICTED
 * Original 22/09/01, Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeRESTRICTED(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   if (setting && !(user->modes & User::MODE_RESTRICTED)) {
      user->modes |= User::MODE_RESTRICTED;
      return true;
   } else if (!setting && (user->modes & User::MODE_RESTRICTED)) {
      user->modes &= ~User::MODE_RESTRICTED;
      return true;
   }
   
   return false;
}


/* User::toggleModeROUTINGSTAFF
 * Original 21/10/01, Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeROUTINGSTAFF(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   if (setting && !(user->modes & User::MODE_ROUTINGSTAFF)) {
      user->modes |= User::MODE_ROUTINGSTAFF;
      return true;
   } else if (!setting && (user->modes & User::MODE_ROUTINGSTAFF)) {
      user->modes &= ~User::MODE_ROUTINGSTAFF;
      return true;
   }
   
   return false;
}


/* User::toggleModeSECURE
 * Original 22/09/01, Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeSECURE(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   if (setting && !(user->modes & User::MODE_SECURE)) {
      user->modes |= User::MODE_SECURE;
      return true;
   } else if (!setting && (user->modes & User::MODE_SECURE)) {
      user->modes &= ~User::MODE_SECURE;
      return true;
   }
   
   return false;
}


/* User::toggleModeSERVNOTICES
 * Original , Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeSERVNOTICES(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   // This should not be set remotely
   if (!user->local) {
      return false;
   }
   
   // Check if we are setting this mode
   if (setting) {
      user->local->serverNotices = 0xFFFFFFFF;
      return true; // fix me
   } 

   // Turn off all the modes
   user->local->serverNotices = 0;
   
   // Return true, since the server notices are turned off completely
   return true;
}


/* User::toggleModeVWORLD
 * Original 25/08/01, Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeVWORLD(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   if (setting && !(user->modes & User::MODE_VWORLD)) {
      user->modes |= User::MODE_VWORLD;
      return true;
   } else if (!setting && (user->modes & User::MODE_VWORLD)) {
      user->modes &= ~User::MODE_VWORLD;
      
      // Warn this user, if we can, about turning off virtual world
      if (handler) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      RPL_MODECHANGEWARN, 0,
			      LNG_RPL_MODECHANGEWARN_MINUS_VWORLD);
      }
      
      return true;
   }

   return false;
}


/* User::toggleModeWALLOPS
 * Original 25/08/01, Simon Butcher <pickle@austnet.org>
 */
bool User::toggleModeWALLOPS(bool setting, Handler *handler, Daemon *daemon, User *user, char *modeChr, String *param)
{
   if (setting && !(user->modes & User::MODE_WALLOPS)) {
      user->modes |= User::MODE_WALLOPS;
      return true;
   } else if (!setting && (user->modes & User::MODE_WALLOPS)) {
      user->modes &= ~User::MODE_WALLOPS;
      
      // Check if we need to (and can) warn this user about this command
      if (handler &&
	  ((user->modes & User::MODE_GLOBALOPER) ||
	   (user->modes & User::MODE_LOCALOPER))) {
	 handler->sendNumeric(TO_DAEMON->myServer(),
			      RPL_MODECHANGEWARN, 0,
			      LNG_RPL_MODECHANGEWARN_IRCOPER_MINUS_WALLOPS);
      }
      
      return true;
   }
   
   return false;
}


/* makeVWorld - Generate a virtual world hash on the given hostname
 * Original , Simon Butcher <pickle@austnet.org>
 */
String User::makeVWorld(String const &hostname)
{
   return String("vw1234.") + hostname;
}


/* addInvitation - Invite us to a channel!
 * Original 19/10/01, Simon Butcher <pickle@austnet.org>
 */
void LocalUser::addInvitation(Channel *channel, User *inviter, time_t expiry)
{
   // Only add it if it is not already there
   if (!invitedTo(channel)) {
      invitations[channel->getName()] =
	new LocalUserInvitation(inviter->getNickname(), expiry);
   }
}


/* invitedTo - Check if we are invited to a specific channel
 * Original 19/10/01, Simon Butcher <pickle@austnet.org>
 */
bool LocalUser::invitedTo(Channel *channel)
{
   // Look up the invitation
   LocalUserInvitation *invite = invitations[channel->getName()];
   
   // Check that we got it
   if (invite) {
      // Check the timeout
      if (!invite->getTimeout() ||
	  (invite->getTimeout() >
	   handler->getConnection()->getDaemon()->getTime())) {
	 // Yes, we are invited to this channel
	 return true;
      } else {
	 // The record has timed out! Delete it and return false
	 invitations.erase(channel->getName());
	 delete invite;
	 
	 return false;
      }
   }
   
   // If we got here we did not get it, and we have to delete what we just made
   invitations.erase(channel->getName());
   
   return false;
};


/* onReplyFloodlockMap - Check for someone on a reply floodlock map
 * Original 21/10/01, Simon Butcher <pickle@austnet.org>
 */
bool LocalUser::onReplyFloodlockMap(LocalUser::floodlock_reply_map_t &lockmap,
				    User *user)
{
   // Fix up the target
   String target = user->getNickname();
   
   // Try and look them up on the map
   time_t timeout = lockmap[target];
   
   // Check if that worked
   if (!timeout) {
      // Add them to the floodlock list
      lockmap[target] = handler->getConnection()->getDaemon()->getTime();
      return false;
   }
   
   // If we got here, check that if the floodlock has timed out
   if ((timeout + FLOODLOCK_AWAY_REPLY) >
       handler->getConnection()->getDaemon()->getTime()) {
      // Timeout is still in effect
      return true;
   }

   // Remove them from the set, the timeout is ineffective now
   lockmap.erase(target);
   return false;
}
